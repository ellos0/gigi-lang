module Codegen where

import Structures

addSemicolon :: String -> String
addSemicolon x = x ++ ";"

jo :: [String] -> String
jo = concat

boilerplate :: String -> String
boilerplate = (jo ["#include <stdio.h>", newlineArray, "//This code was generated by the noble Gigi Compiler.", newlineArray] ++)

codegenCommand :: String -> Statement -> String
codegenCommand  x xs = case x of
  "print" -> jo ["puts(", (codegenStatement (xs)), ")"]
  _ -> ""

codegenFunction :: String -> Statement -> Statement -> String
codegenFunction x1 x2 x3 = jo [((extractTypeAddSpace x2) !! 0), x1, "() {\n", (codegenStatement x3), "\n}"]

codegenStatement :: Statement -> String
codegenStatement (Add x1 x2) = jo [(codegenStatement x1), " + ", (codegenStatement x2)]
codegenStatement (Subtract x1 x2) = jo [(codegenStatement x1), " - ", (codegenStatement x2)]
codegenStatement (Multiply x1 x2) = jo [(codegenStatement x1), " * ", (codegenStatement x2)]
codegenStatement (Divide x1 x2) =  jo [(codegenStatement x1), " / ", (codegenStatement x2)]
codegenStatement (Power x1 x2) = jo [(codegenStatement x1), " ^ ", (codegenStatement x2)]
codegenStatement (Assignment x1 x2 x3) = jo [((extractTypeAddSpace x2) !! 0), x1, " = ", (codegenStatement x3)]
codegenStatement (Defun x1 x2 x3) = codegenFunction x1 x2 x3
codegenStatement (Application x1) = jo [codegenStatement x1, "()"]

codegenStatement (TypeDeclaration _) = ""
codegenStatement (CommandStatement x xs) = codegenCommand x xs 
codegenStatement (Error _) = ""
codegenStatement (NullStatement) = ""
codegenStatement (Literal x) = x
codegenStatement (StringLiteral x1) = [doubleQuote] ++ x1 ++ [doubleQuote]
codegenStatement (IntLiteral x) = x
codegenStatement (Multi xs) = foldr (++) "" (map codegenStatementNewline xs)

codegenStatementSemicolon :: Statement -> String
codegenStatementSemicolon = addSemicolon . codegenStatement

codegenStatementNewline :: Statement -> String
codegenStatementNewline = addNewline . codegenStatementSemicolon 
